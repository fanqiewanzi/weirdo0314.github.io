<!DOCTYPE html>
<html lang="en"><meta charset="utf-8"><meta name="generator" content="Hugo 0.101.0" /><meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover">
<meta name="color-scheme" content="light dark">
<meta name="supported-color-schemes" content="light dark"><title>Google_rate_limit_source_code&nbsp;&ndash;&nbsp;Bazinga Blog Site</title><link rel="stylesheet" href="/css/core.min.63f706677e61b4ee62b8daf083358d3bbf8ac8ab03c7d171af3180fab3a3ebb83efb79fb98674f13dde6db11de2bf694.css" integrity="sha384-Y/cGZ35htO5iuNrwgzWNO7&#43;KyKsDx9FxrzGA&#43;rOj67g&#43;&#43;3n7mGdPE93m2xHeK/aU"><meta name="twitter:card" content="summary" />
<meta name="twitter:title" content="Google_rate_limit_source_code" /><body><section id="header">
    <div class="header wrap"><span class="header left-side"><a class="site home" href="/"><span class="site name">Bazinga Blog Site</span></a></span>
        <span class="header right-side"><div class="nav wrap"><nav class="nav"><a class="nav item" href="/categories/">Categories</a><a class="nav item" href="/tags/">Tags</a><a class="nav item" href="/about">About</a><a class="nav item" href="https://gohugo%2eio/"target="_blank" rel="noopener noreferrer">Hugo</a></nav></div></span></div><div class="site slogan"><span class="title">100% JavaScript-free</span></div></section><section id="content"><div class="article-container"><section class="article header">
    <h1 class="article title">Google_rate_limit_source_code</h1><p class="article date">Friday, October 7, 2022</p></section><article class="article markdown-body"><h3 id="google-golang-rate-limit-source-code">google golang rate limit source code</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// Limit defines the maximum frequency of some events.
</span></span></span><span class="line"><span class="cl"><span class="c1">// Limit is represented as number of events per second.
</span></span></span><span class="line"><span class="cl"><span class="c1">// A zero Limit allows no events.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">type</span> <span class="nx">Limit</span> <span class="kt">float64</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// Inf is the infinite rate limit; it allows all events (even if burst is zero).
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">const</span> <span class="nx">Inf</span> <span class="p">=</span> <span class="nf">Limit</span><span class="p">(</span><span class="nx">math</span><span class="p">.</span><span class="nx">MaxFloat64</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// Every converts a minimum time interval between events to a Limit.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">Every</span><span class="p">(</span><span class="nx">interval</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Duration</span><span class="p">)</span> <span class="nx">Limit</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">interval</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="nx">Inf</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="mi">1</span> <span class="o">/</span> <span class="nf">Limit</span><span class="p">(</span><span class="nx">interval</span><span class="p">.</span><span class="nf">Seconds</span><span class="p">())</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><ul>
<li>定义了一个类型Limit，底层类型为float64，用来表示最大事件发生的频率，这里的定义是允许每秒事件发生的次数，且值为0时拒绝所有事件发生</li>
<li>Inf定义了一个最大的限制频率，它允许所有事件发生，即使在桶大小为0的情况下，这里的burst指的是每秒能够接受的最大令牌个数，也就是桶的大小</li>
<li>Every(internal time.Duration) Limit返回以秒为单位计算的事件发生最小间隔时间，如果internal参数为0，则返回Inf</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">Limiter</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">mu</span>     <span class="nx">sync</span><span class="p">.</span><span class="nx">Mutex</span>
</span></span><span class="line"><span class="cl">	<span class="nx">limit</span>  <span class="nx">Limit</span>
</span></span><span class="line"><span class="cl">	<span class="nx">burst</span>  <span class="kt">int</span>
</span></span><span class="line"><span class="cl">	<span class="nx">tokens</span> <span class="kt">float64</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// last is the last time the limiter&#39;s tokens field was updated
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">last</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Time</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// lastEvent is the latest time of a rate-limited event (past or future)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">lastEvent</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Time</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// Limit returns the maximum overall event rate.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">lim</span> <span class="o">*</span><span class="nx">Limiter</span><span class="p">)</span> <span class="nf">Limit</span><span class="p">()</span> <span class="nx">Limit</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">lim</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="k">defer</span> <span class="nx">lim</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nx">lim</span><span class="p">.</span><span class="nx">limit</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// Burst returns the maximum burst size. Burst is the maximum number of tokens
</span></span></span><span class="line"><span class="cl"><span class="c1">// that can be consumed in a single call to Allow, Reserve, or Wait, so higher
</span></span></span><span class="line"><span class="cl"><span class="c1">// Burst values allow more events to happen at once.
</span></span></span><span class="line"><span class="cl"><span class="c1">// A zero Burst allows no events, unless limit == Inf.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">lim</span> <span class="o">*</span><span class="nx">Limiter</span><span class="p">)</span> <span class="nf">Burst</span><span class="p">()</span> <span class="kt">int</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">lim</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="k">defer</span> <span class="nx">lim</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nx">lim</span><span class="p">.</span><span class="nx">burst</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// NewLimiter returns a new Limiter that allows events up to rate r and permits
</span></span></span><span class="line"><span class="cl"><span class="c1">// bursts of at most b tokens.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">NewLimiter</span><span class="p">(</span><span class="nx">r</span> <span class="nx">Limit</span><span class="p">,</span> <span class="nx">b</span> <span class="kt">int</span><span class="p">)</span> <span class="o">*</span><span class="nx">Limiter</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="o">&amp;</span><span class="nx">Limiter</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">limit</span><span class="p">:</span> <span class="nx">r</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">		<span class="nx">burst</span><span class="p">:</span> <span class="nx">b</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// Allow is shorthand for AllowN(time.Now(), 1).
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">lim</span> <span class="o">*</span><span class="nx">Limiter</span><span class="p">)</span> <span class="nf">Allow</span><span class="p">()</span> <span class="kt">bool</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nx">lim</span><span class="p">.</span><span class="nf">AllowN</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nf">Now</span><span class="p">(),</span> <span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// AllowN reports whether n events may happen at time now.
</span></span></span><span class="line"><span class="cl"><span class="c1">// Use this method if you intend to drop / skip events that exceed the rate limit.
</span></span></span><span class="line"><span class="cl"><span class="c1">// Otherwise use Reserve or Wait.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">lim</span> <span class="o">*</span><span class="nx">Limiter</span><span class="p">)</span> <span class="nf">AllowN</span><span class="p">(</span><span class="nx">now</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Time</span><span class="p">,</span> <span class="nx">n</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nx">lim</span><span class="p">.</span><span class="nf">reserveN</span><span class="p">(</span><span class="nx">now</span><span class="p">,</span> <span class="nx">n</span><span class="p">,</span> <span class="mi">0</span><span class="p">).</span><span class="nx">ok</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><ul>
<li>Limiter定义了限流器的结构体，这里是使用了令牌桶算法进行实现的限流算法，最开始令牌桶中是满的且会根据一定的频率每秒放入r个令牌
<ul>
<li>mu为一个互斥锁，因为每次使用限流器都会对限流器的令牌数量进行更改</li>
<li>limit表示最大事件发生的频率，这里的定义是允许每秒事件发生的次数，且值为0时拒绝所有事件发生</li>
<li>burst表示对应突发事件能够同时处理的最大事件数，这里也代表桶大小</li>
<li>tokens表示桶中令牌数量</li>
<li>last表示最近一次限流器令牌数量更新的事件</li>
<li>lastEvent表示最近一次事件发生的时间，可能是过去的时间，也有可能为未来的时间</li>
</ul>
</li>
<li>限流器限制放入令牌的频率为每秒放入r个令牌，面对突发容量，最大可以同时处理burst个事件</li>
<li>在r==Inf特殊情况下，burst会被忽略</li>
<li>在burst为0时也是一个有效的限流器，但它会拒绝所有事件</li>
<li>使用NewLimiter()方法创建一个非0的限流器</li>
<li>Allow方法判断限流器中是否还有可用的令牌，如果有返回true，否则返回false，AllowN表示限流器中是否还有N个可用令牌</li>
<li>Reserve方法判断限流器中是否还有可用的令牌，如果没有则返回一个预定器，用来表示未来期望的令牌和调用方使用前必须等待的时间长度，ReserveN方法判断限流器中是否还有N个可用的令牌</li>
<li>Wait方法判断限流器中是否还有可用的令牌，如果没有则会阻塞直到得到令牌为止或阻塞到上下文取消为止，WaitN方法判断限流器中是否还有N个可用的令牌</li>
<li>Limit方法和Burst方法分别返回限流器中limit和burst两个属性，在访问这了两个属性的时候都需要加锁保证并发安全</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// A Reservation holds information about events that are permitted by a Limiter to happen after a delay.
</span></span></span><span class="line"><span class="cl"><span class="c1">// A Reservation may be canceled, which may enable the Limiter to permit additional events.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">type</span> <span class="nx">Reservation</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">ok</span>        <span class="kt">bool</span>
</span></span><span class="line"><span class="cl">	<span class="nx">lim</span>       <span class="o">*</span><span class="nx">Limiter</span>
</span></span><span class="line"><span class="cl">	<span class="nx">tokens</span>    <span class="kt">int</span>
</span></span><span class="line"><span class="cl">	<span class="nx">timeToAct</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Time</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// This is the Limit at reservation time, it can change later.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">limit</span> <span class="nx">Limit</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// OK returns whether the limiter can provide the requested number of tokens
</span></span></span><span class="line"><span class="cl"><span class="c1">// within the maximum wait time.  If OK is false, Delay returns InfDuration, and
</span></span></span><span class="line"><span class="cl"><span class="c1">// Cancel does nothing.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">r</span> <span class="o">*</span><span class="nx">Reservation</span><span class="p">)</span> <span class="nf">OK</span><span class="p">()</span> <span class="kt">bool</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nx">r</span><span class="p">.</span><span class="nx">ok</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// Delay is shorthand for DelayFrom(time.Now()).
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">r</span> <span class="o">*</span><span class="nx">Reservation</span><span class="p">)</span> <span class="nf">Delay</span><span class="p">()</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Duration</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nx">r</span><span class="p">.</span><span class="nf">DelayFrom</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nf">Now</span><span class="p">())</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// InfDuration is the duration returned by Delay when a Reservation is not OK.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">const</span> <span class="nx">InfDuration</span> <span class="p">=</span> <span class="nx">time</span><span class="p">.</span><span class="nf">Duration</span><span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">63</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// DelayFrom returns the duration for which the reservation holder must wait
</span></span></span><span class="line"><span class="cl"><span class="c1">// before taking the reserved action.  Zero duration means act immediately.
</span></span></span><span class="line"><span class="cl"><span class="c1">// InfDuration means the limiter cannot grant the tokens requested in this
</span></span></span><span class="line"><span class="cl"><span class="c1">// Reservation within the maximum wait time.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">r</span> <span class="o">*</span><span class="nx">Reservation</span><span class="p">)</span> <span class="nf">DelayFrom</span><span class="p">(</span><span class="nx">now</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Time</span><span class="p">)</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Duration</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="p">!</span><span class="nx">r</span><span class="p">.</span><span class="nx">ok</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="nx">InfDuration</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">delay</span> <span class="o">:=</span> <span class="nx">r</span><span class="p">.</span><span class="nx">timeToAct</span><span class="p">.</span><span class="nf">Sub</span><span class="p">(</span><span class="nx">now</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">delay</span> <span class="p">&lt;</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nx">delay</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// Cancel is shorthand for CancelAt(time.Now()).
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">r</span> <span class="o">*</span><span class="nx">Reservation</span><span class="p">)</span> <span class="nf">Cancel</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">r</span><span class="p">.</span><span class="nf">CancelAt</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nf">Now</span><span class="p">())</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// CancelAt indicates that the reservation holder will not perform the reserved action
</span></span></span><span class="line"><span class="cl"><span class="c1">// and reverses the effects of this Reservation on the rate limit as much as possible,
</span></span></span><span class="line"><span class="cl"><span class="c1">// considering that other reservations may have already been made.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">r</span> <span class="o">*</span><span class="nx">Reservation</span><span class="p">)</span> <span class="nf">CancelAt</span><span class="p">(</span><span class="nx">now</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Time</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="p">!</span><span class="nx">r</span><span class="p">.</span><span class="nx">ok</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">r</span><span class="p">.</span><span class="nx">lim</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="k">defer</span> <span class="nx">r</span><span class="p">.</span><span class="nx">lim</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">r</span><span class="p">.</span><span class="nx">lim</span><span class="p">.</span><span class="nx">limit</span> <span class="o">==</span> <span class="nx">Inf</span> <span class="o">||</span> <span class="nx">r</span><span class="p">.</span><span class="nx">tokens</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="nx">r</span><span class="p">.</span><span class="nx">timeToAct</span><span class="p">.</span><span class="nf">Before</span><span class="p">(</span><span class="nx">now</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// calculate tokens to restore
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// The duration between lim.lastEvent and r.timeToAct tells us how many tokens were reserved
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// after r was obtained. These tokens should not be restored.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">restoreTokens</span> <span class="o">:=</span> <span class="nb">float64</span><span class="p">(</span><span class="nx">r</span><span class="p">.</span><span class="nx">tokens</span><span class="p">)</span> <span class="o">-</span> <span class="nx">r</span><span class="p">.</span><span class="nx">limit</span><span class="p">.</span><span class="nf">tokensFromDuration</span><span class="p">(</span><span class="nx">r</span><span class="p">.</span><span class="nx">lim</span><span class="p">.</span><span class="nx">lastEvent</span><span class="p">.</span><span class="nf">Sub</span><span class="p">(</span><span class="nx">r</span><span class="p">.</span><span class="nx">timeToAct</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">restoreTokens</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// advance time to now
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">now</span><span class="p">,</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">tokens</span> <span class="o">:=</span> <span class="nx">r</span><span class="p">.</span><span class="nx">lim</span><span class="p">.</span><span class="nf">advance</span><span class="p">(</span><span class="nx">now</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// calculate new number of tokens
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">tokens</span> <span class="o">+=</span> <span class="nx">restoreTokens</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">burst</span> <span class="o">:=</span> <span class="nb">float64</span><span class="p">(</span><span class="nx">r</span><span class="p">.</span><span class="nx">lim</span><span class="p">.</span><span class="nx">burst</span><span class="p">);</span> <span class="nx">tokens</span> <span class="p">&gt;</span> <span class="nx">burst</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">tokens</span> <span class="p">=</span> <span class="nx">burst</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// update state
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">r</span><span class="p">.</span><span class="nx">lim</span><span class="p">.</span><span class="nx">last</span> <span class="p">=</span> <span class="nx">now</span>
</span></span><span class="line"><span class="cl">	<span class="nx">r</span><span class="p">.</span><span class="nx">lim</span><span class="p">.</span><span class="nx">tokens</span> <span class="p">=</span> <span class="nx">tokens</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">r</span><span class="p">.</span><span class="nx">timeToAct</span> <span class="o">==</span> <span class="nx">r</span><span class="p">.</span><span class="nx">lim</span><span class="p">.</span><span class="nx">lastEvent</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">prevEvent</span> <span class="o">:=</span> <span class="nx">r</span><span class="p">.</span><span class="nx">timeToAct</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="nx">r</span><span class="p">.</span><span class="nx">limit</span><span class="p">.</span><span class="nf">durationFromTokens</span><span class="p">(</span><span class="nb">float64</span><span class="p">(</span><span class="o">-</span><span class="nx">r</span><span class="p">.</span><span class="nx">tokens</span><span class="p">)))</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="p">!</span><span class="nx">prevEvent</span><span class="p">.</span><span class="nf">Before</span><span class="p">(</span><span class="nx">now</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nx">r</span><span class="p">.</span><span class="nx">lim</span><span class="p">.</span><span class="nx">lastEvent</span> <span class="p">=</span> <span class="nx">prevEvent</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><ul>
<li>Reservation表示预定器结构体，结构体保存的信息为限流器允许延迟一段时间后发生的事件的限流相关信息，预定器可能被取消，可能会导致限流器允许其他事件
<ul>
<li>ok表示是否在最大等待事件内提供预定器预定的令牌数量</li>
<li>lim为限流器的指针</li>
<li>tokens表示预定器事件需要的令牌数量</li>
<li>timeToAct表示事件预计的发生时间</li>
<li>limit表示预定器创建时限流器每秒的最大发生事件频率</li>
</ul>
</li>
<li>OK方法返回限流器是否能在最大等待事件内提供预定器预定的令牌数量，如果为false，Delay方法会返回最大等待时间，Cancel方法什么都不会做</li>
<li>Delay方法为DelayFrom(time.Now())的封装</li>
<li>InfDuration定义了最大等待时间，为1&laquo;63-1</li>
<li>DelayFrom方法返回预定器执行事件之前需要等待的时间，当返回值为0时代表立即执行，当限流器无法提供相应个数令牌时返回最大等待事件InfDuration</li>
<li>Cancel方法为CancelAt(time.Now())的封装</li>
<li>CancelAt方法表示预定器不会执行相应的方法，尽可能地反转预定器对限流器地影响，且需要考虑其他预定器同时操作的并发安全问题，因为会对限流器进行更改
<ul>
<li>首先判断Reservation中的ok属性，因为ok中途不会改变，在初始化Reservatioin时已经定死，当在预计等待时间内没有相应个数的令牌时就为false，代表这个预定器的事件不会被执行，所以影响不到限流器，直接返回</li>
<li>为了保证并发安全，把限流器中的锁加上</li>
<li>当限流器中的limit属性为Inf，表示不限制频率时，这时候限流器会忽略掉burst属性也就是桶的大小，预定器取消对限流器没有任何影响，直接返回；当预定器中事件所需要的令牌数量为0时，对限流器也没有任何影响，直接返回；当预定器中的预定事件发生事件小于传入的当前时间时，这时候表示事件已经过了预定发生时间了，预定器指定的事件不会执行，所以对限流器没有影响，直接返回。</li>
<li>接下来计算需要重置的令牌数量，在限流器的最近事件发生时间和预定器的预定事件发生事件的时间差值所产生的令牌不应被还原到限流器中，这里指的是当限流器的最近时间发生时间已经在预定器预定发生时间之后了，因为计算预定发生时间是根据需要的令牌数量计算的，如果可以执行的话限流器已经减去相应的令牌数量了，但如果预定事件并没有发生而是执行了Cancel这时候需要还原限流器的令牌需要减去已经生成的令牌数量</li>
<li>接下来加上限流器需要更新的令牌数量，即当前时间与上次更新令牌时间计算出最新的令牌数量，最后加上预定器返回的令牌数量，更新到限流器中，这里更新限流器中的两个属性，一个是last表示最近一次更新令牌桶数量的时间，一个是tokens表示更新后限流器中令牌的数量</li>
<li>最后判断预定器预计发生时间是否和限流器中最近事件发生时间是否相等，如果相等则会计算预定器所需要的令牌数量的时间长度，如果小于当前时间，则将限流器中的最近事件发生事件更新为刚刚计算的事件</li>
</ul>
</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// Reserve is shorthand for ReserveN(time.Now(), 1).
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">lim</span> <span class="o">*</span><span class="nx">Limiter</span><span class="p">)</span> <span class="nf">Reserve</span><span class="p">()</span> <span class="o">*</span><span class="nx">Reservation</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nx">lim</span><span class="p">.</span><span class="nf">ReserveN</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nf">Now</span><span class="p">(),</span> <span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// ReserveN returns a Reservation that indicates how long the caller must wait before n events happen.
</span></span></span><span class="line"><span class="cl"><span class="c1">// The Limiter takes this Reservation into account when allowing future events.
</span></span></span><span class="line"><span class="cl"><span class="c1">// The returned Reservation’s OK() method returns false if n exceeds the Limiter&#39;s burst size.
</span></span></span><span class="line"><span class="cl"><span class="c1">// Usage example:
</span></span></span><span class="line"><span class="cl"><span class="c1">//   r := lim.ReserveN(time.Now(), 1)
</span></span></span><span class="line"><span class="cl"><span class="c1">//   if !r.OK() {
</span></span></span><span class="line"><span class="cl"><span class="c1">//     // Not allowed to act! Did you remember to set lim.burst to be &gt; 0 ?
</span></span></span><span class="line"><span class="cl"><span class="c1">//     return
</span></span></span><span class="line"><span class="cl"><span class="c1">//   }
</span></span></span><span class="line"><span class="cl"><span class="c1">//   time.Sleep(r.Delay())
</span></span></span><span class="line"><span class="cl"><span class="c1">//   Act()
</span></span></span><span class="line"><span class="cl"><span class="c1">// Use this method if you wish to wait and slow down in accordance with the rate limit without dropping events.
</span></span></span><span class="line"><span class="cl"><span class="c1">// If you need to respect a deadline or cancel the delay, use Wait instead.
</span></span></span><span class="line"><span class="cl"><span class="c1">// To drop or skip events exceeding rate limit, use Allow instead.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">lim</span> <span class="o">*</span><span class="nx">Limiter</span><span class="p">)</span> <span class="nf">ReserveN</span><span class="p">(</span><span class="nx">now</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Time</span><span class="p">,</span> <span class="nx">n</span> <span class="kt">int</span><span class="p">)</span> <span class="o">*</span><span class="nx">Reservation</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">r</span> <span class="o">:=</span> <span class="nx">lim</span><span class="p">.</span><span class="nf">reserveN</span><span class="p">(</span><span class="nx">now</span><span class="p">,</span> <span class="nx">n</span><span class="p">,</span> <span class="nx">InfDuration</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="o">&amp;</span><span class="nx">r</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// Wait is shorthand for WaitN(ctx, 1).
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">lim</span> <span class="o">*</span><span class="nx">Limiter</span><span class="p">)</span> <span class="nf">Wait</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">)</span> <span class="p">(</span><span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nx">lim</span><span class="p">.</span><span class="nf">WaitN</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// WaitN blocks until lim permits n events to happen.
</span></span></span><span class="line"><span class="cl"><span class="c1">// It returns an error if n exceeds the Limiter&#39;s burst size, the Context is
</span></span></span><span class="line"><span class="cl"><span class="c1">// canceled, or the expected wait time exceeds the Context&#39;s Deadline.
</span></span></span><span class="line"><span class="cl"><span class="c1">// The burst limit is ignored if the rate limit is Inf.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">lim</span> <span class="o">*</span><span class="nx">Limiter</span><span class="p">)</span> <span class="nf">WaitN</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">n</span> <span class="kt">int</span><span class="p">)</span> <span class="p">(</span><span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">lim</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="nx">burst</span> <span class="o">:=</span> <span class="nx">lim</span><span class="p">.</span><span class="nx">burst</span>
</span></span><span class="line"><span class="cl">	<span class="nx">limit</span> <span class="o">:=</span> <span class="nx">lim</span><span class="p">.</span><span class="nx">limit</span>
</span></span><span class="line"><span class="cl">	<span class="nx">lim</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">n</span> <span class="p">&gt;</span> <span class="nx">burst</span> <span class="o">&amp;&amp;</span> <span class="nx">limit</span> <span class="o">!=</span> <span class="nx">Inf</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Errorf</span><span class="p">(</span><span class="s">&#34;rate: Wait(n=%d) exceeds limiter&#39;s burst %d&#34;</span><span class="p">,</span> <span class="nx">n</span><span class="p">,</span> <span class="nx">burst</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// Check if ctx is already cancelled
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">select</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">case</span> <span class="o">&lt;-</span><span class="nx">ctx</span><span class="p">.</span><span class="nf">Done</span><span class="p">():</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="nx">ctx</span><span class="p">.</span><span class="nf">Err</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="k">default</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// Determine wait limit
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">now</span> <span class="o">:=</span> <span class="nx">time</span><span class="p">.</span><span class="nf">Now</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="nx">waitLimit</span> <span class="o">:=</span> <span class="nx">InfDuration</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">deadline</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">ctx</span><span class="p">.</span><span class="nf">Deadline</span><span class="p">();</span> <span class="nx">ok</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">waitLimit</span> <span class="p">=</span> <span class="nx">deadline</span><span class="p">.</span><span class="nf">Sub</span><span class="p">(</span><span class="nx">now</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// Reserve
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">r</span> <span class="o">:=</span> <span class="nx">lim</span><span class="p">.</span><span class="nf">reserveN</span><span class="p">(</span><span class="nx">now</span><span class="p">,</span> <span class="nx">n</span><span class="p">,</span> <span class="nx">waitLimit</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="p">!</span><span class="nx">r</span><span class="p">.</span><span class="nx">ok</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Errorf</span><span class="p">(</span><span class="s">&#34;rate: Wait(n=%d) would exceed context deadline&#34;</span><span class="p">,</span> <span class="nx">n</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// Wait if necessary
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">delay</span> <span class="o">:=</span> <span class="nx">r</span><span class="p">.</span><span class="nf">DelayFrom</span><span class="p">(</span><span class="nx">now</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">delay</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">t</span> <span class="o">:=</span> <span class="nx">time</span><span class="p">.</span><span class="nf">NewTimer</span><span class="p">(</span><span class="nx">delay</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">defer</span> <span class="nx">t</span><span class="p">.</span><span class="nf">Stop</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="k">select</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">case</span> <span class="o">&lt;-</span><span class="nx">t</span><span class="p">.</span><span class="nx">C</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// We can proceed.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="k">return</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl">	<span class="k">case</span> <span class="o">&lt;-</span><span class="nx">ctx</span><span class="p">.</span><span class="nf">Done</span><span class="p">():</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// Context was canceled before we could proceed.  Cancel the
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="c1">// reservation, which may permit other events to proceed sooner.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="nx">r</span><span class="p">.</span><span class="nf">Cancel</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="nx">ctx</span><span class="p">.</span><span class="nf">Err</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// SetLimit is shorthand for SetLimitAt(time.Now(), newLimit).
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">lim</span> <span class="o">*</span><span class="nx">Limiter</span><span class="p">)</span> <span class="nf">SetLimit</span><span class="p">(</span><span class="nx">newLimit</span> <span class="nx">Limit</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">lim</span><span class="p">.</span><span class="nf">SetLimitAt</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nf">Now</span><span class="p">(),</span> <span class="nx">newLimit</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// SetLimitAt sets a new Limit for the limiter. The new Limit, and Burst, may be violated
</span></span></span><span class="line"><span class="cl"><span class="c1">// or underutilized by those which reserved (using Reserve or Wait) but did not yet act
</span></span></span><span class="line"><span class="cl"><span class="c1">// before SetLimitAt was called.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">lim</span> <span class="o">*</span><span class="nx">Limiter</span><span class="p">)</span> <span class="nf">SetLimitAt</span><span class="p">(</span><span class="nx">now</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Time</span><span class="p">,</span> <span class="nx">newLimit</span> <span class="nx">Limit</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">lim</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="k">defer</span> <span class="nx">lim</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">now</span><span class="p">,</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">tokens</span> <span class="o">:=</span> <span class="nx">lim</span><span class="p">.</span><span class="nf">advance</span><span class="p">(</span><span class="nx">now</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">lim</span><span class="p">.</span><span class="nx">last</span> <span class="p">=</span> <span class="nx">now</span>
</span></span><span class="line"><span class="cl">	<span class="nx">lim</span><span class="p">.</span><span class="nx">tokens</span> <span class="p">=</span> <span class="nx">tokens</span>
</span></span><span class="line"><span class="cl">	<span class="nx">lim</span><span class="p">.</span><span class="nx">limit</span> <span class="p">=</span> <span class="nx">newLimit</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// SetBurst is shorthand for SetBurstAt(time.Now(), newBurst).
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">lim</span> <span class="o">*</span><span class="nx">Limiter</span><span class="p">)</span> <span class="nf">SetBurst</span><span class="p">(</span><span class="nx">newBurst</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">lim</span><span class="p">.</span><span class="nf">SetBurstAt</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nf">Now</span><span class="p">(),</span> <span class="nx">newBurst</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// SetBurstAt sets a new burst size for the limiter.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">lim</span> <span class="o">*</span><span class="nx">Limiter</span><span class="p">)</span> <span class="nf">SetBurstAt</span><span class="p">(</span><span class="nx">now</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Time</span><span class="p">,</span> <span class="nx">newBurst</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">lim</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="k">defer</span> <span class="nx">lim</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">now</span><span class="p">,</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">tokens</span> <span class="o">:=</span> <span class="nx">lim</span><span class="p">.</span><span class="nf">advance</span><span class="p">(</span><span class="nx">now</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">lim</span><span class="p">.</span><span class="nx">last</span> <span class="p">=</span> <span class="nx">now</span>
</span></span><span class="line"><span class="cl">	<span class="nx">lim</span><span class="p">.</span><span class="nx">tokens</span> <span class="p">=</span> <span class="nx">tokens</span>
</span></span><span class="line"><span class="cl">	<span class="nx">lim</span><span class="p">.</span><span class="nx">burst</span> <span class="p">=</span> <span class="nx">newBurst</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><ul>
<li>Reserve方法封装了ReservN(time.Now(), 1)</li>
<li>ReserveN方法返回一个预定器，具体实现在reserveN方法</li>
<li>Wait方法封装了WaitN(ctx, 1)</li>
<li>WaitN方法阻塞直到限流器允许N个事件发生，也就是需要N个令牌才能继续进行，当请求的n大于限流器桶的大小且限流器的limit参数不为Inf时会返回一个错误，当上下文被取消时也会返回一个错误，这里就体现了当limit参数为Inf时桶大小会被忽略的特性了
<ul>
<li>根据上下文传递的超时时间来计算最大的等待时间，如果上下文不是一个DeadLine上下文，默认的最大等待时间为InfDuration</li>
<li>然后获取一个预定器，具体实现在reserveN方法中，判断时间可以是否在未来正常执行，如果不能则返回一个超时错误</li>
<li>计算当前时间与需要等待的时间点的差值，如果为0则nil，表示无需等待可以继续执行</li>
<li>新建一个定时器，根据差值进行监听判断是否可以继续执行，如果上下文被关闭，返回错误</li>
</ul>
</li>
<li>SetLimit方法封装了SetLimitAt(time.Now(), newLimit)</li>
<li>SetLimitAt方法更新limit值并更新限流器中令牌的数量</li>
<li>SetBurst方法封装了SetBurstAt(time.Now(), newBurst).</li>
<li>SetBurstAt方法更新burst值并更新限流器中令牌的数量</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// reserveN is a helper method for AllowN, ReserveN, and WaitN.
</span></span></span><span class="line"><span class="cl"><span class="c1">// maxFutureReserve specifies the maximum reservation wait duration allowed.
</span></span></span><span class="line"><span class="cl"><span class="c1">// reserveN returns Reservation, not *Reservation, to avoid allocation in AllowN and WaitN.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">lim</span> <span class="o">*</span><span class="nx">Limiter</span><span class="p">)</span> <span class="nf">reserveN</span><span class="p">(</span><span class="nx">now</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Time</span><span class="p">,</span> <span class="nx">n</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">maxFutureReserve</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Duration</span><span class="p">)</span> <span class="nx">Reservation</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">lim</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">lim</span><span class="p">.</span><span class="nx">limit</span> <span class="o">==</span> <span class="nx">Inf</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">       <span class="nx">lim</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">       <span class="k">return</span> <span class="nx">Reservation</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">          <span class="nx">ok</span><span class="p">:</span>        <span class="kc">true</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">          <span class="nx">lim</span><span class="p">:</span>       <span class="nx">lim</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">          <span class="nx">tokens</span><span class="p">:</span>    <span class="nx">n</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">          <span class="nx">timeToAct</span><span class="p">:</span> <span class="nx">now</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">   <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nx">now</span><span class="p">,</span> <span class="nx">last</span><span class="p">,</span> <span class="nx">tokens</span> <span class="o">:=</span> <span class="nx">lim</span><span class="p">.</span><span class="nf">advance</span><span class="p">(</span><span class="nx">now</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// Calculate the remaining number of tokens resulting from the request.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">tokens</span> <span class="o">-=</span> <span class="nb">float64</span><span class="p">(</span><span class="nx">n</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// Calculate the wait duration
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kd">var</span> <span class="nx">waitDuration</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Duration</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">tokens</span> <span class="p">&lt;</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">       <span class="nx">waitDuration</span> <span class="p">=</span> <span class="nx">lim</span><span class="p">.</span><span class="nx">limit</span><span class="p">.</span><span class="nf">durationFromTokens</span><span class="p">(</span><span class="o">-</span><span class="nx">tokens</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">   <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// Decide result
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">n</span> <span class="o">&lt;=</span> <span class="nx">lim</span><span class="p">.</span><span class="nx">burst</span> <span class="o">&amp;&amp;</span> <span class="nx">waitDuration</span> <span class="o">&lt;=</span> <span class="nx">maxFutureReserve</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// Prepare reservation
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">r</span> <span class="o">:=</span> <span class="nx">Reservation</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">       <span class="nx">ok</span><span class="p">:</span>    <span class="nx">ok</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">       <span class="nx">lim</span><span class="p">:</span>   <span class="nx">lim</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">       <span class="nx">limit</span><span class="p">:</span> <span class="nx">lim</span><span class="p">.</span><span class="nx">limit</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">   <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">ok</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">       <span class="nx">r</span><span class="p">.</span><span class="nx">tokens</span> <span class="p">=</span> <span class="nx">n</span>
</span></span><span class="line"><span class="cl">       <span class="nx">r</span><span class="p">.</span><span class="nx">timeToAct</span> <span class="p">=</span> <span class="nx">now</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="nx">waitDuration</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">   <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// Update state
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="nx">ok</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">       <span class="nx">lim</span><span class="p">.</span><span class="nx">last</span> <span class="p">=</span> <span class="nx">now</span>
</span></span><span class="line"><span class="cl">       <span class="nx">lim</span><span class="p">.</span><span class="nx">tokens</span> <span class="p">=</span> <span class="nx">tokens</span>
</span></span><span class="line"><span class="cl">       <span class="nx">lim</span><span class="p">.</span><span class="nx">lastEvent</span> <span class="p">=</span> <span class="nx">r</span><span class="p">.</span><span class="nx">timeToAct</span>
</span></span><span class="line"><span class="cl">   <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">       <span class="nx">lim</span><span class="p">.</span><span class="nx">last</span> <span class="p">=</span> <span class="nx">last</span>
</span></span><span class="line"><span class="cl">   <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nx">lim</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nx">r</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// advance calculates and returns an updated state for lim resulting from the passage of time.
</span></span></span><span class="line"><span class="cl"><span class="c1">// lim is not changed.
</span></span></span><span class="line"><span class="cl"><span class="c1">// advance requires that lim.mu is held.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">lim</span> <span class="o">*</span><span class="nx">Limiter</span><span class="p">)</span> <span class="nf">advance</span><span class="p">(</span><span class="nx">now</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Time</span><span class="p">)</span> <span class="p">(</span><span class="nx">newNow</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Time</span><span class="p">,</span> <span class="nx">newLast</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Time</span><span class="p">,</span> <span class="nx">newTokens</span> <span class="kt">float64</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">last</span> <span class="o">:=</span> <span class="nx">lim</span><span class="p">.</span><span class="nx">last</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">now</span><span class="p">.</span><span class="nf">Before</span><span class="p">(</span><span class="nx">last</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">       <span class="nx">last</span> <span class="p">=</span> <span class="nx">now</span>
</span></span><span class="line"><span class="cl">   <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// Calculate the new number of tokens, due to time that passed.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">elapsed</span> <span class="o">:=</span> <span class="nx">now</span><span class="p">.</span><span class="nf">Sub</span><span class="p">(</span><span class="nx">last</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nx">delta</span> <span class="o">:=</span> <span class="nx">lim</span><span class="p">.</span><span class="nx">limit</span><span class="p">.</span><span class="nf">tokensFromDuration</span><span class="p">(</span><span class="nx">elapsed</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nx">tokens</span> <span class="o">:=</span> <span class="nx">lim</span><span class="p">.</span><span class="nx">tokens</span> <span class="o">+</span> <span class="nx">delta</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">burst</span> <span class="o">:=</span> <span class="nb">float64</span><span class="p">(</span><span class="nx">lim</span><span class="p">.</span><span class="nx">burst</span><span class="p">);</span> <span class="nx">tokens</span> <span class="p">&gt;</span> <span class="nx">burst</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">       <span class="nx">tokens</span> <span class="p">=</span> <span class="nx">burst</span>
</span></span><span class="line"><span class="cl">   <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nx">now</span><span class="p">,</span> <span class="nx">last</span><span class="p">,</span> <span class="nx">tokens</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// durationFromTokens is a unit conversion function from the number of tokens to the duration
</span></span></span><span class="line"><span class="cl"><span class="c1">// of time it takes to accumulate them at a rate of limit tokens per second.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kd">func</span> <span class="p">(</span><span class="nx">limit</span> <span class="nx">Limit</span><span class="p">)</span> <span class="nf">durationFromTokens</span><span class="p">(</span><span class="nx">tokens</span> <span class="kt">float64</span><span class="p">)</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Duration</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">seconds</span> <span class="o">:=</span> <span class="nx">tokens</span> <span class="o">/</span> <span class="nb">float64</span><span class="p">(</span><span class="nx">limit</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nx">time</span><span class="p">.</span><span class="nf">Duration</span><span class="p">(</span><span class="nb">float64</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span> <span class="o">*</span> <span class="nx">seconds</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// tokensFromDuration is a unit conversion function from a time duration to the number of tokens
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// which could be accumulated during that duration at a rate of limit tokens per second.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kd">func</span> <span class="p">(</span><span class="nx">limit</span> <span class="nx">Limit</span><span class="p">)</span> <span class="nf">tokensFromDuration</span><span class="p">(</span><span class="nx">d</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Duration</span><span class="p">)</span> <span class="kt">float64</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nx">d</span><span class="p">.</span><span class="nf">Seconds</span><span class="p">()</span> <span class="o">*</span> <span class="nb">float64</span><span class="p">(</span><span class="nx">limit</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><ul>
<li>判断限流器中的limit属性是否为Inf，如果是则直接返回相应的数据结构，因为不限制执行所以调用方拿到之后就可以继续往下执行</li>
<li>接下来计算限流器中总的令牌数量，减去所需要的令牌数量，如果剩余令牌数量小于0，则计算相应的需要等待的时间</li>
<li>计算预定器是否有效，也就是ok属性，由一个与运算进行计算，当所需令牌数小于等于同大小且需要等待的时间小于最大等待时间时为true，否则为false</li>
<li>如果预定器有效，则初始化预定器tokens属性和timeToAct属性</li>
<li>如果预定器有效，需要更新限流器中的last/tokens/lastEvent值，否则只更新last</li>
<li>advance方法计算限流器现在时间到上次时间更新所产生的令牌数量，并加上现有的令牌数量，返回三个参数：现在时间、最近更新时间、令牌数量</li>
<li>durationFromTokens方法返回产生N个令牌所需要的时间，单位为秒</li>
<li>tokensFromDuration方法返回d时间长度，单位为秒的时间内能够产生的令牌数量
总结</li>
<li>google实现的这个令牌桶算法很标准，并没有通过特定的协程每秒往令牌桶中放入令牌，而是将放入令牌这个操作分散到每个方法的调用上，这样减少了锁的竞争也使得整个限流过程更加流畅</li>
<li>在平时使用时如果达到限流器限制直接返回错误的话可以使用Allow方法，如果想进行等待令牌的话可以使用Wait方法，Wait方法底层是Reserve方法，底层是使用的定时器进行等待的，在现在的golang调度器来看，定时器的机制可以很好的保证每次定时都可以检测到，非常好用</li>
</ul>
</article>
</div>
<div class="article bottom"><section class="article navigation"><p><a class="link" href="/content/linux1/"><span class="iconfont icon-article"></span>Linux目录结构</a></p></section></div></section><section id="footer"><div class="footer-wrap">
    <p class="copyright">Bazinga Blog Site</p>
    <p class="powerby"><span>Powered&nbsp;by&nbsp;</span><a href="https://gohugo.io" 
        target="_blank" rel="noopener noreferrer">Hugo</a><span>&nbsp;&amp;&nbsp;</span><a href="https://themes.gohugo.io/hugo-notepadium/" 
        target="_blank" rel="noopener noreferrer">Notepadium</a>
<a href='https://ipv6-test.com/validate.php?url=referer'
  ><img src='https://ipv6-test.com/button-ipv6-80x15.png' 
        alt='ipv6 ready' title='ipv6 ready' border='0' 
/></a>
</p></div>
</section></body>

</html>